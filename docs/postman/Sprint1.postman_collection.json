{
	"info": {
		"_postman_id": "561b0836-1be1-4810-a365-f37f685fa218",
		"name": "DFSP Backend — Sprint 1",
		"description": "DFSP backend tests: Health + Auth PoP (EIP-712). Pre-request скрипты подписывают EIP-712 прямо в Postman.",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "23342115",
		"_collection_link": "https://speeding-moon-921909.postman.co/workspace/Team-Workspace~d6c15df2-0448-48ab-84ca-911386f90cac/collection/23342115-561b0836-1be1-4810-a365-f37f685fa218?action=share&source=collection_link&creator=23342115"
	},
	"item": [
		{
			"name": "Health",
			"item": [
				{
					"name": "Health: /healthz",
					"event": [
						{
							"listen": "test",
							"script": {
								"type": "text/javascript",
								"exec": [
									"pm.test(\"Status 200\", function () { pm.response.to.have.status(200); });",
									"const j = pm.response.json();",
									"pm.test(\"Body ok=true\", function () { pm.expect(j.ok).to.be.true; });"
								]
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{API_BASE}}/healthz",
							"host": [
								"{{API_BASE}}"
							],
							"path": [
								"healthz"
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "Auth",
			"item": [
				{
					"name": "Auth: Challenge (register)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test('200 OK', ()=> pm.response.to.have.status(200));",
									"const j = pm.response.json();",
									"",
									"pm.environment.set('CHALLENGE_ID', j.challenge_id);",
									"pm.environment.set('NONCE', j.nonce);",
									"",
									"// Сразу положим каркас AUTH_TYPED_DATA (адрес подставится в pre-request)",
									"const typed = {",
									"  domain: { name: 'DFSP-Login', version: '1' },",
									"  types: { LoginChallenge: [",
									"    { name: 'address', type: 'address' },",
									"    { name: 'nonce',   type: 'bytes32' }",
									"  ]},",
									"  primaryType: 'LoginChallenge',",
									"  message: { address: pm.environment.get('ETH_ADDRESS') || '0x'+'0'.repeat(40), nonce: j.nonce }",
									"};",
									"pm.environment.set('AUTH_TYPED_DATA', JSON.stringify(typed));",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{}"
						},
						"url": {
							"raw": "{{API_BASE}}/auth/challenge",
							"host": [
								"{{API_BASE}}"
							],
							"path": [
								"auth",
								"challenge"
							]
						}
					},
					"response": []
				},
				{
					"name": "Auth: Register",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// ---------- безопасные геттеры ----------",
									"const getStr = (key, required=false) => {",
									"  // тянем из всех скоупов (request/collection/env/globals)",
									"  let v = pm.variables.get(key);",
									"  if (v === null || v === undefined) v = '';",
									"  else if (typeof v !== 'string') v = String(v);",
									"  v = v.trim();",
									"  // уберём случайные кавычки",
									"  if ((v.startsWith('\"') && v.endsWith('\"')) || (v.startsWith(\"'\") && v.endsWith(\"'\"))) {",
									"    v = v.slice(1, -1).trim();",
									"  }",
									"  if (required && !v) pm.expect.fail(`${key} is required (put it in Environment → Current Value)`);",
									"  return v;",
									"};",
									"",
									"const getJSON = (key, required=false) => {",
									"  const raw = pm.variables.get(key);",
									"  if (raw && typeof raw === 'object') return raw;",
									"  const s = getStr(key, required);",
									"  if (!s) return null;",
									"  try { return JSON.parse(s); }",
									"  catch (e) { pm.expect.fail(`${key} must be valid JSON: ${e}`); }",
									"};",
									"",
									"const setStr = (k, v) => pm.environment.set(k, String(v ?? '').trim());",
									"const HEX = (n) => new RegExp(`^0x[0-9a-fA-F]{${n}}$`);",
									"const ENSURE = (cond, msg) => { if (!cond) pm.expect.fail(msg); };",
									"",
									"// ---------- берём/строим typed_data ----------",
									"let typed = getJSON('AUTH_TYPED_DATA'); // можно заранее положить готовый JSON",
									"if (!typed) {",
									"  // если нет — соберём каркас из NONCE (domain фиксированный)",
									"  const nonce = getStr('NONCE', true);",
									"  ENSURE(HEX(64).test(nonce), 'NONCE invalid (need 0x + 64 hex)');",
									"  const zero = '0x' + '0'.repeat(40);",
									"  typed = {",
									"    domain: { name: 'DFSP-Login', version: '1' },",
									"    types: { LoginChallenge: [",
									"      { name: 'address', type: 'address' },",
									"      { name: 'nonce',   type: 'bytes32' }",
									"    ]},",
									"    primaryType: 'LoginChallenge',",
									"    message: { address: zero, nonce }",
									"  };",
									"  setStr('AUTH_TYPED_DATA', JSON.stringify(typed));",
									"}",
									"",
									"// ---------- адрес и подпись ----------",
									"let addr = getStr('ETH_ADDRESS');                   // ты кладёшь из оффлайн-скрипта",
									"if (!addr && typed?.message?.address) addr = String(typed.message.address).trim();",
									"ENSURE(HEX(40).test(addr), 'ETH_ADDRESS invalid (need 0x + 40 hex)');",
									"",
									"const sig = getStr('AUTH_SIGNATURE', true);         // тоже из оффлайн-скрипта",
									"ENSURE(HEX(130).test(sig), 'AUTH_SIGNATURE invalid (need 0x + 130 hex)');",
									"",
									"const challengeId = getStr('CHALLENGE_ID', true);",
									"",
									"// гарантируем правильный адрес в typed.message",
									"typed.message = typed.message || {};",
									"typed.message.address = addr;",
									"",
									"// ---------- собираем body ----------",
									"const isRegister = pm.request.url.toString().endsWith('/auth/register');",
									"",
									"const rsaPublic = getStr('RSA_PUBLIC') || 'test';",
									"const displayName = getStr('DISPLAY_NAME') || 'Postman Tester';",
									"",
									"const body = isRegister",
									"  ? {",
									"      rsa_public: rsaPublic,",
									"      eth_address: addr,",
									"      display_name: displayName,",
									"      challenge_id: challengeId,",
									"      signature: sig,",
									"      typed_data: typed",
									"    }",
									"  : {",
									"      eth_address: addr,",
									"      challenge_id: challengeId,",
									"      signature: sig,",
									"      typed_data: typed",
									"    };",
									"",
									"// заголовок и тело",
									"pm.request.headers.upsert({ key: 'Content-Type', value: 'application/json' });",
									"pm.request.body.update(JSON.stringify(body));",
									"",
									"// на всякий — вернём адрес в окружение",
									"setStr('ETH_ADDRESS', addr);",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test('200 OK', ()=> pm.response.to.have.status(200));",
									"const j = pm.response.json();",
									"pm.test('Tokens present', ()=> { pm.expect(j).to.have.property('access'); pm.expect(j).to.have.property('refresh'); });",
									"pm.environment.set('ACCESS_TOKEN', j.access);",
									"pm.environment.set('REFRESH_TOKEN', j.refresh);",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{}"
						},
						"url": {
							"raw": "{{API_BASE}}/auth/register",
							"host": [
								"{{API_BASE}}"
							],
							"path": [
								"auth",
								"register"
							]
						}
					},
					"response": []
				},
				{
					"name": "Auth: Challenge (login)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test('200 OK', ()=> pm.response.to.have.status(200));",
									"const j = pm.response.json();",
									"",
									"pm.environment.set('CHALLENGE_ID', j.challenge_id);",
									"pm.environment.set('NONCE', j.nonce);",
									"",
									"// Сразу положим каркас AUTH_TYPED_DATA (адрес подставится в pre-request)",
									"const typed = {",
									"  domain: { name: 'DFSP-Login', version: '1' },",
									"  types: { LoginChallenge: [",
									"    { name: 'address', type: 'address' },",
									"    { name: 'nonce',   type: 'bytes32' }",
									"  ]},",
									"  primaryType: 'LoginChallenge',",
									"  message: { address: pm.environment.get('ETH_ADDRESS') || '0x'+'0'.repeat(40), nonce: j.nonce }",
									"};",
									"pm.environment.set('AUTH_TYPED_DATA', JSON.stringify(typed));",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"packages": {},
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{}"
						},
						"url": {
							"raw": "{{API_BASE}}/auth/challenge",
							"host": [
								"{{API_BASE}}"
							],
							"path": [
								"auth",
								"challenge"
							]
						}
					},
					"response": []
				},
				{
					"name": "Auth: Login",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// ---------- безопасные геттеры ----------",
									"const getStr = (key, required=false) => {",
									"  // тянем из всех скоупов (request/collection/env/globals)",
									"  let v = pm.variables.get(key);",
									"  if (v === null || v === undefined) v = '';",
									"  else if (typeof v !== 'string') v = String(v);",
									"  v = v.trim();",
									"  // уберём случайные кавычки",
									"  if ((v.startsWith('\"') && v.endsWith('\"')) || (v.startsWith(\"'\") && v.endsWith(\"'\"))) {",
									"    v = v.slice(1, -1).trim();",
									"  }",
									"  if (required && !v) pm.expect.fail(`${key} is required (put it in Environment → Current Value)`);",
									"  return v;",
									"};",
									"",
									"const getJSON = (key, required=false) => {",
									"  const raw = pm.variables.get(key);",
									"  if (raw && typeof raw === 'object') return raw;",
									"  const s = getStr(key, required);",
									"  if (!s) return null;",
									"  try { return JSON.parse(s); }",
									"  catch (e) { pm.expect.fail(`${key} must be valid JSON: ${e}`); }",
									"};",
									"",
									"const setStr = (k, v) => pm.environment.set(k, String(v ?? '').trim());",
									"const HEX = (n) => new RegExp(`^0x[0-9a-fA-F]{${n}}$`);",
									"const ENSURE = (cond, msg) => { if (!cond) pm.expect.fail(msg); };",
									"",
									"// ---------- берём/строим typed_data ----------",
									"let typed = getJSON('AUTH_TYPED_DATA'); // можно заранее положить готовый JSON",
									"if (!typed) {",
									"  // если нет — соберём каркас из NONCE (domain фиксированный)",
									"  const nonce = getStr('NONCE', true);",
									"  ENSURE(HEX(64).test(nonce), 'NONCE invalid (need 0x + 64 hex)');",
									"  const zero = '0x' + '0'.repeat(40);",
									"  typed = {",
									"    domain: { name: 'DFSP-Login', version: '1' },",
									"    types: { LoginChallenge: [",
									"      { name: 'address', type: 'address' },",
									"      { name: 'nonce',   type: 'bytes32' }",
									"    ]},",
									"    primaryType: 'LoginChallenge',",
									"    message: { address: zero, nonce }",
									"  };",
									"  setStr('AUTH_TYPED_DATA', JSON.stringify(typed));",
									"}",
									"",
									"// ---------- адрес и подпись ----------",
									"let addr = getStr('ETH_ADDRESS');                   // ты кладёшь из оффлайн-скрипта",
									"if (!addr && typed?.message?.address) addr = String(typed.message.address).trim();",
									"ENSURE(HEX(40).test(addr), 'ETH_ADDRESS invalid (need 0x + 40 hex)');",
									"",
									"const sig = getStr('AUTH_SIGNATURE', true);         // тоже из оффлайн-скрипта",
									"ENSURE(HEX(130).test(sig), 'AUTH_SIGNATURE invalid (need 0x + 130 hex)');",
									"",
									"const challengeId = getStr('CHALLENGE_ID', true);",
									"",
									"// гарантируем правильный адрес в typed.message",
									"typed.message = typed.message || {};",
									"typed.message.address = addr;",
									"",
									"// ---------- собираем body ----------",
									"const isRegister = pm.request.url.toString().endsWith('/auth/register');",
									"",
									"const rsaPublic = getStr('RSA_PUBLIC') || 'test';",
									"const displayName = getStr('DISPLAY_NAME') || 'Postman Tester';",
									"",
									"const body = isRegister",
									"  ? {",
									"      rsa_public: rsaPublic,",
									"      eth_address: addr,",
									"      display_name: displayName,",
									"      challenge_id: challengeId,",
									"      signature: sig,",
									"      typed_data: typed",
									"    }",
									"  : {",
									"      eth_address: addr,",
									"      challenge_id: challengeId,",
									"      signature: sig,",
									"      typed_data: typed",
									"    };",
									"",
									"// заголовок и тело",
									"pm.request.headers.upsert({ key: 'Content-Type', value: 'application/json' });",
									"pm.request.body.update(JSON.stringify(body));",
									"",
									"// на всякий — вернём адрес в окружение",
									"setStr('ETH_ADDRESS', addr);",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test('200 OK', ()=> pm.response.to.have.status(200));",
									"const j = pm.response.json();",
									"pm.test('Tokens present', ()=> { pm.expect(j).to.have.property('access'); pm.expect(j).to.have.property('refresh'); });",
									"pm.environment.set('ACCESS_TOKEN', j.access);",
									"pm.environment.set('REFRESH_TOKEN', j.refresh);",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{}"
						},
						"url": {
							"raw": "{{API_BASE}}/auth/login",
							"host": [
								"{{API_BASE}}"
							],
							"path": [
								"auth",
								"login"
							]
						}
					},
					"response": []
				}
			],
			"description": "EIP-712 PoP: Challenge → Register → Challenge → Login"
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"packages": {},
				"requests": {},
				"exec": [
					""
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"packages": {},
				"requests": {},
				"exec": [
					""
				]
			}
		}
	],
	"variable": [
		{
			"key": "API_BASE",
			"value": "http://localhost:8000"
		},
		{
			"key": "ETH_ADDRESS",
			"value": ""
		},
		{
			"key": "AUTH_SIGNATURE",
			"value": ""
		},
		{
			"key": "AUTH_TYPED_DATA",
			"value": ""
		},
		{
			"key": "CHALLENGE_ID",
			"value": ""
		}
	]
}